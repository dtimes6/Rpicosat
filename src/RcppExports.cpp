// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>
extern "C" {
	#include "picosat.h"
}

using namespace Rcpp;

const char* reason [] = {
	"",
	"'0' cannot be used as lit."
};

int
addClause(PicoSAT* picosat, IntegerVector clause) {
	int sz = clause.size();
	for (int i = 0; i < sz; ++i) {
		int lit = clause[i];
		if (lit == 0) {
			return -1; // See reason of error for details
		}
		picosat_add(picosat, lit);
	}
	picosat_add(picosat, 0);
	return 0;
}

int
addClauses(PicoSAT* picosat, List clauses) {
	int sz = clauses.size();
	for (int i = 0; i < sz; ++i) {
		if (addClause(picosat, clauses[i]) < 0) {
			return -1;
		}
	}
	return 0;
}

IntegerVector
getSolution(PicoSAT *picosat) {
	int max_idx = picosat_variables(picosat);
	IntegerVector res(max_idx);
	for (int i = 1; i <= max_idx; ++i) {
		res[i - 1] = picosat_deref(picosat, i) * i;
	}
	return res;
}

RcppExport SEXP
Rpicosat_solve(SEXP cnf_in) {
	PicoSAT* picosat = picosat_init();
	int s = addClauses(picosat, cnf_in);
	if (s < 0) {
		List err = List::create(_["status"] = "ERROR", _["reason"] = reason[-s]);
		return err;
	}

	int res = picosat_sat(picosat, -1);

	List result;
	switch (res) {
	case PICOSAT_SATISFIABLE:
		result = List::create(_["status"] = "SAT", _["clause"] = getSolution(picosat));
		break;

	case PICOSAT_UNSATISFIABLE:
		result = List::create(_["status"] = "UNSAT");
		break;

	case PICOSAT_UNKNOWN:
		result = List::create(_["status"] = "UNKNOWN");
		break;
	}

	picosat_reset(picosat);
	return result;
}
